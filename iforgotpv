#!/bin/bash

# Function to display help
show_help() {
    echo "Usage: ./iforgotpv <pid> [fd] [interval]"
    echo "  pid      : Process ID"
    echo "  fd       : File descriptor (optional)"
    echo "  interval : Update interval in seconds (optional, default: 1)"
    echo
    echo "If only PID is provided, it will list file descriptors and exit."
    echo "If no arguments are given, this help message is displayed."
}

# Function to list file descriptors
list_file_descriptors() {
    local pid=$1
    echo "File descriptors for PID $pid:"
    ls -l /proc/$pid/fd 2>/dev/null | awk '{print $9 " -> " $11}' || echo "Error: Unable to access file descriptors for PID $pid"
}

# Function to draw progress bar
draw_progress_bar() {
    local percent=$1
    local width=50
    local completed=$((percent * width / 100))
    printf "\r["
    printf "%0.s#" $(seq 1 $completed)
    printf "%0.s-" $(seq 1 $((width - completed)))
    printf "] %3d%%" $percent
}

# Check arguments
if [ $# -eq 0 ]; then
    show_help
    exit 0
elif [ $# -eq 1 ]; then
    list_file_descriptors $1
    exit 0
fi

# Parse arguments
PID=$1
FD=$2
INTERVAL=${3:-1}

# Function to check if process is still running
check_process() {
    if ! kill -0 $PID 2>/dev/null; then
        echo "Error: Process $PID has terminated."
        exit 1
    fi
}

# Resolve the symbolic link to get the actual file path
FILE_PATH=$(readlink /proc/$PID/fd/$FD 2>/dev/null)
if [ -z "$FILE_PATH" ]; then
    echo "Error: Unable to resolve file path for PID $PID and FD $FD"
    exit 1
fi

# Get the total file size in bytes
FILE_SIZE=$(stat -c %s "$FILE_PATH" 2>/dev/null)
if [ -z "$FILE_SIZE" ]; then
    echo "Error: Unable to get file size for $FILE_PATH"
    exit 1
fi

# Convert file size to GB
FILE_SIZE_GB=$(echo "scale=6; $FILE_SIZE / (1024 * 1024 * 1024)" | bc)

# Initialize variables
PREV_POS=$(awk '/pos/ {print $2}' /proc/$PID/fdinfo/$FD 2>/dev/null)
if [ -z "$PREV_POS" ]; then
    echo "Error: Unable to get initial position for PID $PID and FD $FD"
    exit 1
fi

WEIGHTED_SPEED=0
ALPHA=0.2  # Weight for the moving average

# Hide the cursor
tput civis

# Print static parts of the output
echo "Process ID: $PID"
echo "File Descriptor: $FD"
echo "File Size: $FILE_SIZE_GB GB"
echo
echo "Progress:"
echo
echo "Current Position:"
echo "Distance from End:"
echo "Estimated Time to Finish:"

# Start the continuous loop
while true
do
    # Check if the process is still running
    check_process

    # Get the current position
    CURRENT_POS=$(awk '/pos/ {print $2}' /proc/$PID/fdinfo/$FD 2>/dev/null)
    if [ -z "$CURRENT_POS" ]; then
        echo "Error: Unable to get current position for PID $PID and FD $FD"
        exit 1
    fi

    # Calculate the change in position since the last check
    CHANGE=$(( CURRENT_POS - PREV_POS ))

    # Calculate the current distance from the end of the file
    DISTANCE=$(( FILE_SIZE - CURRENT_POS ))

    # Convert current position and distance to GB
    CURRENT_POS_GB=$(echo "scale=6; $CURRENT_POS / (1024 * 1024 * 1024)" | bc)
    DISTANCE_GB=$(echo "scale=6; $DISTANCE / (1024 * 1024 * 1024)" | bc)

    # Calculate the percentage complete
    PERCENT_COMPLETE=$(echo "scale=2; ($CURRENT_POS / $FILE_SIZE) * 100" | bc)

    # Update weighted average speed
    CURRENT_SPEED=$((CHANGE / INTERVAL))
    WEIGHTED_SPEED=$(echo "scale=2; ($ALPHA * $CURRENT_SPEED) + ((1 - $ALPHA) * $WEIGHTED_SPEED)" | bc)

    # Calculate the estimated time to finish in seconds and then convert to minutes
    if [[ $(echo "$WEIGHTED_SPEED > 0" | bc -l) -eq 1 ]]; then
        TIME_TO_FINISH_SEC=$(echo "scale=2; $DISTANCE / $WEIGHTED_SPEED" | bc)
        TIME_TO_FINISH_MIN=$(echo "scale=2; $TIME_TO_FINISH_SEC / 60" | bc)
    else
        TIME_TO_FINISH_MIN="Infinite (No Progress Detected)"
    fi

    # Move cursor and update dynamic parts
    tput cup 5 0
    draw_progress_bar ${PERCENT_COMPLETE%.*}
    tput cup 7 0
    printf "\rCurrent Position: %9.6f GB" $CURRENT_POS_GB
    tput cup 8 0
    printf "\rDistance from End: %9.6f GB" $DISTANCE_GB
    tput cup 9 0
    printf "\rEstimated Time to Finish: %s minutes     " "$TIME_TO_FINISH_MIN"

    # Update the previous position
    PREV_POS=$CURRENT_POS

    # Pause for the specified interval
    sleep $INTERVAL
done
